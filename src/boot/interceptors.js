// import { eventHub } from '../../config.js'
import { Dialog } from "quasar"

export default (http, store, router) => {
  http.interceptors.request.use((config) => {
    // Do something before request is sent
    return store.dispatch("checkRefreshToken").then((token) => {
      // console.log(token)
      if (token) {
       config.headers.common.Authorization = `Bearer ${token}`
      }
      return config
    })
  })

  // https://github.com/mzabriskie/axios#interceptors
  http.interceptors.request.use(
    function(config) {
      // Do something before request is sent
      if (store.state.language != null) {
        config.headers["x-language"] = store.state.language
      } else {
        config.headers["x-language"] = "pt-br"
      }

      if (store.state.selected_station) {
        config.headers["X-StationId"] =
          store.state.selected_station.stationId || sessionStorage.stationId
      }

      return config
    },
    function(error) {
      // Do something with request error
      return Promise.reject(error)
    }
  )

  http.interceptors.response.use(
    (response) => {
      return response
    },
    /**
     * This is a central point to handle all
     * error messages generated by HTTP
     * requests
     */
    (error) => {
      const { response } = error
      console.log(response)

      if ([401].indexOf(response.status) > -1) {
        // store.dispatch('checkRefreshToken2');
        router.push({
          name: "requestAccessToken",
          query: { redirectUrl: window.location.href }
        })
        // store.dispatch(SEND_NOTIFY, {
        //   title: `Sessão`,
        //   message: 'Sua sessão expirou, por favor faça login novamente.',
        //   type: 'info'
        // });
      } else if ([403].indexOf(response.status) > -1) {
        router.push({ name: "stations" })
      } else {
        // alert(JSON.stringify(response))
        Dialog.create({
          title: "Ops... Houve um problema!",
          message:
            `
            <b>Algo ocorreu ao tentar processar sua ação. Veja abaixo detalhes do ocorrido:</b>
            <br/><br/>` + JSON.stringify(response),
          html: true,
          cancel: false,
          ok: {
            label: "Ok",
            "no-caps": true,
            color: "red-8"
          }
        })
        // store.dispatch(SEND_NOTIFY, {
        //   title: `Erro ${response.status}`,
        //   message: response.data && response.data.message ? `${response.data.message}` : error.message,
        //   type: 'error'
        // });
      }
      console.log(response.status)
      /* if (error && error.response) {
        if (error.response.status) {
          if (error.response.status === 400) {
            eventHub.$emit('error', 400)
            } else if (error.response.status === 401) {
              eventHub.$emit('error', 401)
            } else if (error.response.status === 403) {
              eventHub.$emit('error', 403)
            } else if (error.response.status === 500) {
              eventHub.$emit('error', 500)
            } else if (error.response.status === 502) {
              eventHub.$emit('error', 502)
            } else if (error.response.status === 503) {
              eventHub.$emit('error', 503)
            } else if (error.response.status === 504) {
              eventHub.$emit('error', 504)
            }
          }
        }
        /**
        * If token is either expired, not provided or invalid
        * then redirect to login. On server side the error
        * messages can be changed on app/Providers/EventServiceProvider.php
        */
      /* if ([401, 400].indexOf(response.status) > -1) {
      //router.push({ name: 'login' })
      }
      /**
      * Error messages are sent in arrays
      */
      if (typeof response.data.push === "function") {
        // if (isArray(response.data)) {
        // store.dispatch('setMessage', { type: 'error', message: response.data.messages })
      } else {
        // store.dispatch('setMessage', { type: 'validation', message: response.data })
      }
      // store.dispatch('setFetching', { fetching: false })
      return Promise.reject(error)
    }
  )
}
